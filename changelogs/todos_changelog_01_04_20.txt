TODOs and Changelog from 01/04/20

CHANGELOG:

Format:
- dd/mm/yy: change + brief info
            - extra info on indented line

Some entries marked with an asterisk may have changed:
[CHANGED ON dd/mm/yy]     -> a feature whose behaviour/implementation has
                              changed
[DEPRECATED ON dd/mm/yy]  -> a feature that has been removed
[IMPLEMENTED ON dd/mm/yy] -> a feature that was mentioned or whose framework
                              was added and has now been written
[ADDED TO ON dd/mm/yy]    -> a feature that has been added to

(Other specific changes may be written in square brackets too, if a certain
 reference in an older entry is still valid but something other than
 the feature itself has changed e.g. a renamed keyword)

The date on which a Github commit was made may also be present to easily see
what's changed between releases

- 01/04/20: fixed a bug with parsing commands (internal) where a flag
            was parsed as a keyword
            - bug discovered while using help command and error wrongly
              occured
            - fixed by moving flag parsing before keyword parsing in
              CLIParser.part_matches_token
- 01/04/20: api.new_tag now does call the 2 tag name plugin hooks as before
            it didn't which was incorrect
- 01/04/20: changed rendering of tags with multiple values in default display
            hook:
            - different items will render on new lines with commas at the end
              of each
            - the indent will match the end of the name of the tag + colon
- 02/04/20: added '-p' ('--plugins') option to command line interface
            (argparse) which can specify a specific directory in which to look
            for plugins other than in tagger/plugins
- 02/04/20: the 'config' tag of the root of a data tree which specifies which
            plugin file to use for hooks now requires that the file extension
            of the plugin file is given
- 02/04/20: changed + moved api.HookDispatcher to structure.NameDispatcher
- 02/04/20: added api.log to hold data about events (moved existing api
            variables into this too):
            - this uses structure.NameDispatcher like api.plugin to convert
              an attribute access into a dictionary lookup so all names can be
              accessed e.g. with 'api.log.unsaved_changes'
        **  - the names held in the log at the moment are:
              - 'unsaved_changes' (migrated from api.unsaved_changes) which is
                a bool indicating - to a certain extent - whether there are
                modifications to the data tree that have not been saved
                - this requires the use of api.edits as a decorator on
                  functions that modify the data tree (ones in the api like
                  api.new_tag already have this)
                - this only relies on the fact that the SaveCommand will
                  reset 'unsaved_changes' back to False
                - this won't take into account the possibility that the file
                  that had been saved to hasn't been deleted already
                - this doesn't take into account that any other command/hook
                  registered by other files may reset this value too
              - 'plugin_file' (migrated from api._config) which is a string
                containing the name of the plugin file given in the tag
                'config' of the root of the data tree (or None if not
                present)
              - 'plugin_loaded' (new) which is a bool indicating whether the
                plugin file was successfully loaded; it is True unless:
                - accessed before api.initialise_plugins has run, or
                - there is no plugin file given, or
                - the given plugin file was not found in tagger/plugins, or
                - (if an alternative plugins directory was given) the given
                  plugin file was not found in the alternative directory
              - 'warnings_on' (migrated from api.WARNING) which indicates
                whether the option '--warnings' ('-w') was present at startup
                - this value still could be changed (even temporarily) by
                  another plugin file
              - 'alternative_plugins_dir' which is a string of a path to the
                directory in which to search for plugins other than in
                tagger/plugins
                - this value can be changed, however if plugins have already
                  been initialised (api.initialise_plugins called), the
                  plugins in the new directory won't be automatically
                  registered unless api.initialise_plugins is called again
              - 'data source' which is a string of the path to the input data
        **  [ADDED TO ON 04/04/20]
            [ADDED TO ON 14/04/20]
- 02/04/20: added API hook 'api.plugin.startup_hook' which will be called as
            soon as the given plugin file ('config' tag of root) is loaded
            successfully
            - (api.initialise_plugin will call this hook)
- 02/04/20: changed plugin initialisation order so that now the function
            api.initialise_plugins will try to load the given plugin file
            before trying to import other command files so that the hook
            api.plugin.startup_hook is called as early as possible
- 02/04/20: after startup, the number of overridden hooks and new commands
            registered will be displayed
- 03/04/20: api.resolve renamed to api.resolve_command to remove ambiguity
            and so that its name matches similar command like
            api.resolve_signature
- 04/04/20: changed how api.test_input works with multiple error messages so
            now the error message will be chosen based on which input test
            function failed - functions should not return a number to
            correspond with an index
            - api.tests.is_valid_child_index changed so now it will return
              a list of the 3 test functions it holds (it still accepts a
              number or a Node object)
            - the list returned should be unpacked into api.test_input:
            - api.test_input(i, [msgs], *api.is_valid_child_index(n))
- 04/04/20: added api.is_node(node) to perform an instance check:
            - isinstance(node, (structure.Node, structure.Root))
- 04/04/20: implemented 'edit data' command and added api.edit_data(new, node)
            base function
- 04/04/20: added api.log.is_startup to indicate whether the program is
            in startup phase (initialising plugins and creating data tree)
            - this can be used in plugin hooks to use different behaviour
              at startup
- 04/04/20: structure.NameDispatcher(ref, warn) now also accepts the
            'warn' argument which will, if any value other than None, will
            make the dispatcher produce an APIWarning if a new name is added
            to its reference
            - the value of 'warn' is printed in the warning message so it
              should be a string
            - the name of the key being assigned to is added to the end of the
              warning message
            - api.log uses this to warn when a new log value is added
- 04/04/20: SaveCommand updated syntax 'save [as \'name\'|current] [and exit]'
            - feature added is 'save as current' which will use
              api.log.data_source as the file name + directory to save the data
              tree to (it should be the same as the input data and therefore
              will overwrite it)
            - obviously, it is still possible for other plugins to modify the
              value of api.log.data_source
- 04/04/20: tagger.plugins.default.WhatCommand now can quit the listing of all
            of the commands' help entry by typing 'q'
[COMMITED ON 04/04/20]
- 06/04/20: cleaned up argparse help message
- 06/04/20: removed a legacy feature that allowed comments at the END of the
            data source to be ignored
- 06/04/20: structure.NameDispatcher accepts error_if_none argument which will
            raise an error if the value it returns is None - this is
            used by api.plugin to warn when (probably) the default plugin
            file was not registered instead of a generic NoneType TypeError
- 06/04/20: made it easier to manually call the CLI and perform setup:
            - added api.manual_setup(data_source, warnings, alt_plugins_dir)
              which will assign the corresponding value to api.log and import
              the default/fallback plugin hooks
            - __main__.py now uses this in combination with argparse
            - api.make_tree now accepts a file name instead of a direct text
              source with make_tree(file='<file>')
            - to manually call the CLI, follow these steps:
              - import the API with 'from tagger import api' or equivalent
              - call api.manual_setup(data_source, warnings, alt_plugins_dir):
                (all parameters are optional, but it must be called to import
                 the default plugin hooks)
              - now call api.make_tree(source=None, file=None) - if no data
                source was given, either 'source' or 'file' must be filled
              - now api.run() can be called
[COMMITTED ON 13/04/20]
- 13/04/20: added function api.priority(p) which should be used as a decorator
            on input handler functions to assign them a priority.
            - manually assigning by doing 'input_handler_x.priority = p'
              still works, but this method is clearer and quicker
            - default.NewDataCommand uses this with a negative priority (-1)
              for one parameter so that it gets checked last
            - other commands that now use the feature are default.InCommand,
              default.EnterCommand
- 13/04/20: added function api.may_return_none which should be used as a
            decorator on input handler functions that may return None as an
            actual value to use
            - this will skip the check in api.execute_command which will (now)
              raise an APIWarning if an input hander returns None because
              there is a greater chance that whoever wrote the function forgot
              to add a return statement to produce a value
            - the attribute input_handler_x.may_return_none can be manually
              set to True as this is what the function itself does
- 13/04/20: implemented command 'edit tag name'
- 14/04/20: fixed a problem where the program would crash when a file in a
            plugin directory is not a valid python file - instead the file is
            skipped
- 14/04/20: changed api._new_hooks and api._new_commands to
            api.log.new_hooks and api.log.new_commands
            - this records how many commands have been registered and how many
              hooks have been overriden (excluding the default hooks)
- 14/04/20: moved api._importing_commands to api.log.importing_commands which
        **  is a boolean value indicating whether to only register commnads
            (and not hooks) from plugin files (at startup)
            [RENAMED ON 17/08/20]
- 14/04/20: added api.reload_plugins and command 'reload <verbose>' which is
            found in plugin.ReloadCommand (command comes with the program)
            [FINISHED ON 04/06/20]
- 14/04/20: added sub-functions in api and renamed api.import_base_plugins
            to api._import_base_plugin:
            - api._import_plugin_file
            - api._import_other_plugins
            - api._import_alt_dir_plugins
- 04/06/20: fixed reload system to force reload by removing modules from
            sys.modules
- 04/06/20: all plugin files can now have a startup_hook() function in their
        **  namespace (NOT within an api.Hooks subclass) which will be called
            as soon as the plugin is loaded
            [CHANGED ON 17/08/20]
- 04/06/20: added 'and clean' flag to 'reload' command:
            - signature is now 'reload <and clean> <verbose>'
            - the presence of this flag will remove any commands that are no
              longer present in any plugin file instead of only adding new
              commands (same for hooks)
- 04/06/20: added api.compile_command(command_str, name) which will return a
            hidden Command subclass that executes the given command (string)
            as if it was typed into the CLI - used in BindCommand
            - command inspection hook will still be called
            - uses existing behaviour of api.prompt, however this has now been
              split into a new function
- 04/06/20: added BindCommand (comes with default package) which will create a
            new command whose .execute method will run the command string
            given, as if it was typed into the CLI
- 04/06/20: added AliasCommand (comes with default package) which will
            create an alias for a command
- 04/06/20: added api.tests.is_valid_command_name which is a list of 2 test
            commands to be unpacked in api.test_input (this does is an
            attribute of api.tests, not a function, so doesn't need to be
            called)
- 06/06/20: added structure.NodeType which is subclassed by both
            structure.Root and structure.Node to allow easier instance type
            checking
- 06/06/20: changed some python old .format strings to new f-strings
- 06/06/20: changed some command parsing semantics which caused an error as
            described below:
            - previously, the parser would stop at the first match when
              checking different parts of an OR expression in a command
              signature
            - this could cause an error when the parser would match a part
              not intended to be matched:
            - the signature '<option> | <option two>' would still match the
              first flag 'option' even when 'option two' may have been typed
              into the CLI because it was the first match
            - now, greedy parsing has been implemented so the parser will try
              to match the longest part out of all possible matches so that
              the longer option will be chosen when present and the shorter
              option is still matched when nothing else matches
- 06/06/20: changed command parsing semantics when parsing optional phrases
            and normal phrases so that they will only be parsed when the whole
            of the phrase is matched
- 06/06/20: fixed recursive dict problem in structure.NameDispatcher dispatch
            reference
- 07/06/20: changed some code in the lexer which should give a small speed
            increase by removing the likelihood of repeated index accesses to
            the same index
- 07/06/20: added docstrings to most of the functions in api/lexer/parser.py
- 25/07/20: data source is no longer required in command line options
            - NodeError is no longer raised if there is no data source at
              startup
            - when there is no data source given at startup, the CLI changes
              its display so that a data source can be loaded using a custom
              loader
- 25/07/20: added api.log.disable_all which is a boolean value which dictates
            whether all commands are disabled or not
- 25/07/20: added api.log.disable_exemptions which is a list of command IDs
            that cannot be disabled - this list should not have permanent names
            in it and should be set for a specific purpose then set back to
            what it was
- 25/07/20: added api.disabled which is a list of commands that are currently
            disabled even if the command's .disabled() method says otherwise
            (this list overrides Command.disabled)
            - api.is_disabled(c) should be used at all times instead of
              checking Command.disabled()
            - the priority of api.is_disabled is as follows:
              - if the command ID is in log.disable_exemptions, return False
              - else, if log.disable_all is True, return True
              - else, if command ID is in log.disabled, return True
              - else return the result of command.disabled()
- 25/07/20: added plugin.LoadCommand which is a command to manually load a data
        **  source from any format (e.g. JSON)
            [IMPLEMENTED ON 26/07/20]
- 25/07/20: when the CLI has no tree loaded, the only commands that are enabled
            are 'help', 'load', 'exit' and 'reload'
- 25/07/20: added plugin.capture_return(returns) to enable the results of
            commands to be captured
            - it is a list in the form [(ID, return)] where each tuple has the
              command ID and its return value as a pair
- 26/07/20: api.execute_command(c) now will check whether a command is disabled
            before execution so disabled commands cannot be run manually either
- 26/07/20: added plugins.JSONLoaderCommand which has the syntax:
            'json loader \'file\''
            - it should only be used by LoadCommand and not directly
            - it loads data in JSON format (see tagger.sample_data.json)
- 26/07/20: added api.found_plugin_file(file, reload=True) which will set
        **  api.plugin_file to the file path and reload plugins
            [CHANGED ON 07/08/20]
- 26/07/20: finished the loading mechanism to manually load a data tree from
            a source in a different format
        **  - plugin.LoadCommand has the syntax:
              'load \'file\' using \'loader\''
              - 'file' is the path (relative/absolute) of the data source
              - 'loader' is the loader command (ID) to use
            - the loader command should be an api.Command subclass whose
              signature is a single string argument which will be used as the
              file path
            - the loader should return a structure.Root instance which will be
              the loaded data tree
            - the loader should use api.found_plugin_file(file) if it is needed
              to load a plugin file
            - api.initialise_commands(reload=True) may be used; however,
              commands will have already been loaded (except plugin hooks) so
              the reload option is needed
            - the loader may choose to mirror the default behaviour of giving a
              data tree the default name 'Tree' if no name is found
            - the loader should use api functions like api.append_tag_value
              to perform checks on data and use plugin hooks automatically if
              loaded
            - structure.Root should be used to create the root
            - api.new_node should be used to create child nodes so plugin hooks
              are executed
              [CHANGED ON 05/08/20]
- 26/07/20: 'return' command extended to support 'return home' which will
            return traversal to the root node instead of having to find what
            depth the current traversal is at
- 27/07/20: added plugin.SetCommand which can be used to set certain values in
            api.log
            - this can be used to change the plugin file more easily when using
              the CLI or to change the alternative plugins directory
- 27/07/20: started to add structure.Capture and parsing for it {capture}
        **  - true/false value
            - can only contain keyword
            - this can be used to test whether an optional phrase was present
              by testing if a keyword was present
            - this can be used to check which option in an OR expression was
              present if all of the options must be non-optional (not a flag or
              optional phrase) and don't have any inputs in them
            - added LBRACE and RBRACE tokens to signature lexer
              [CHANGED ON 29/07/20]
- 28/07/20: added a parser feature where any command being run will have its
            parsed signature set as an attribute on the command class so that
            it doesn't need to be parsed again (saving time)
            - available as Command.sig_cache (no attribute if not yet parsed)
- 29/07/70: started to redesign the signature and CLI parser to make it easier
            to extend
            - changed names of signature element names in structure.py
            - keyword capture will be available
- 04/08/20: changed lexers.SignatureLexer so that keywords in signatures
            can mix upper and lower case (since they'll be converted to
            lowercase anyway)
- 04/08/20: redesigned CLI and signature parser with more implementation in
            structure.py - the spec for command signatures is as follows:
            - string inputs are accepted in the form STRING=arg where
              'arg' is the name of the input
            - number inputs (integers) are accepted in the form NUMBER=arg
              where 'arg' is the name of the input
            - keywords are accepted as-is and can contain letters, underscores
              and digits
              - cannot start with a digit
              - case-insensitive (all converted to lowercase)
              - (uppercase only) STRING and NUMBER imply an input argument
                follows
            - an optional phrase is defined with [square brackets] and can
              contain any signature elements
              - elements in the group will not be parsed if they aren't all
                present in the CLI
            - a grouped phrase is defined with (parentheses) and can contain
              any signature elements
              - they have no effect in CLI parsing and only serve to group a
                set of signature elements into a single element for other
                expressions where usually a single element is required
            - a flag is defined with <angle brackets> (less than/greater than)
              and can contain only keyword elements
              - if all the keywords are present then the flag will be parsed
                and a True value will be passed as the input
              - it is an optional element and its input value will be False if
                the flag's keywords are not present
              - the input parameter name of the flag is all the keywords in
                lowercase, separated by underscores (as: multi_keyword_flag)
            - a capturing keyword is defined with {curly braces} and can
              contain only keywords
              - it is a required element, but a value of True will be passed
                as the input (with the same naming semantics as a flag)
              - the only time it will be false is if it appears within an
                optional/variable phrase
            - to make an element optional, the character ? can be put after it
              - this is only for inputs, keywords, flags, captures and normal
                phrases (not optional phrases)
              - when the 'optional?' marker is for an input, it goes after the
                name like 'STRING=name?'
              - the marker means that the element won't be parsed if it is not
                present
              - if used on an input, there should be a default value provided
                for the input value in the dict Command.defaults
              - if there is no default given, the corresponding input handler,
                if it is defined will be called with a value of None
            - to make a variable element, the character * can be put after it
              - (follows the same parsing rules as optional markers)
              - the marker means that the element will be parsed 0 or more
                times as long as it is still present and can be matched
              - the value(s) for the input will be passed a list, even if there
                are 0 or 1 elements
            - to give a multiple options for 1 element, an OR expression can be
              used with the pipe character |
              - this will mean that any option in the expression can be matched
              - if there are multiple matches, the longest match will be chosen
              - if there are multiple longest matches, the first one
                encountered will be chosen
              - multiple ORs can be chained as option1|option2|option3 etc.
              - ORs have the lowest precedence so they will bind all elements
                classed as a singular into each option, including optional and
                variable markers
              - to bind multiple elements to one option, use a (grouped phrase)
- 05/08/20: added a default loader in plugins/loaders.py to load data trees
            from standard tagger format
            - loader ID is 'default loader'
            - chagned plugin.LoadCommand's syntax to:
              'load \'file \' [using \'loader\']' where the default loader is
              used if no name given
- 05/08/20: extended syntax of ExitCommand so that it is now:
            'exit <and return> <without saving>'
            - if 'withouts aving' is present, the program will end immediately
            - if it is not present and there are no unsaved changed, a prompt
              will appear to confirm
            - if it is not present and there are unsaved changes, the program
              will not end
            - if 'and return' is present, the program will return to the state
              where no data tree is loaded
            - these features are not present when the program has no data tree
              loaded
[COMMITED ON 05/08/20]
- 07/08/20: changed the loader interface so that a dedicated api.Loader
            subclass can be created with the methods 'load' and 'save'
            - the 'load' method should accept a string which is the path to the
              file to load
            - the 'save' method should accept a string which is the file to
              save the data tree to
            - Loader subclasses should have an ID attribute like commands
- 07/08/20: moved api.found_plugin_file to api.Loader.found_plugin_file as it
            is only used in loaders
- 07/08/20: renamed 'json loader' and 'default loader' to 'json' and 'default'
- 07/08/20: moved default saving functions to the default loader and added
            a .save method for the JSON loader too
- 07/08/20: changed behaviour of structure.NameDispatcher and added subclass
            .PluginHookDispatcher to facilitate calls to multiple hooks from
            one name
            - structure.NameDispatcher accepts a dispatch reference, a getter
              hook and a setter hook in __init__
            - getter_hook is a function called with the reference, the key and
              the value retreived (used in __getattribute__)
            - setter_hook is a function called with the same arguments (used
              in __setatttr__)
            - getter_hook should return a value which is the return value of
              the lookup
            - setter_hook should return a value which is used as the new value
            - structure.warn_if_new(message) will return a function used as a
              setter hook that raises an API warning if assigning to a new name
            - structure.error_if_test(test, message) will return a function
              used as a getter hook that calls the test function with the value
              (if the test returns True, TypeError is raised)
- 13/08/20: changing plugins so that certain names can have multiple hooks
            - starting to redesign the plugin hook system so all 'files' are
              'plugin files' and all can define hooks, but for certain hooks,
              only the hook from the designated plugin file will be used
- 13/08/20: 'plugin.startup_hook' should now be defined under an api.Hooks
            subclass
            - it is called as soon as it is registered
- 13/08/20: 'tag_name_input_test' and 'tag_value_input_test' should now not
            return a value and instead raise TypeError so that the default
            error is raise (where there is an invalid value) or NodeError
            if a custom error message is to be used
- 13/08/20: api.log.importing_commands renamed to .importing_main_plugin
            to better describe the meaning
            - when True, it means the main plugin file is being registered
- 19/08/20: added api.register_hook(hook, *, single=False) which can be called
            by plugins to register new hooks
            - 'single' means that the hook is only for the main plugin file
        **  - if 'single' is True, a default hook value should be registered
              to avoid errors
            [IMPLEMENTED METHOD ON 21/08/20]
- 19/08/20: added api.log.currently_importing which is either None or the
            name of the plugin file currently being imported
- 19/08/20: calling the 'reload' command will clear all registered plugins so
            that no duplicates are created when new hooks are re-registered
            - the 'and clean' option will only clean the command registry
- 21/08/20: extended api.register_hoook to register_hook(hook, *, single=False,
            default=None)
            - 'default' must be provided as the default hook (function) if
              'single' is True
- 23/08/20: started to implement Node Reference input type into command
            signatures
            - lexers.NODEREF token type added
            - lexers.DOT token type added
            - lexers.DOTDOT token type added
            - lexers.TILDE token type added
            - lexers.SLASH token type added
            - NODEREF keyword required in command signatures
            - structure.NodeRefInput added to handle parsing
- 23/08/20: changed api.resolve_child to handle negative indices correctly
            - in normal mode, positive indices begin from 0 and negative
              indices begin from -1
            - in offset mode, positive indices start from 1 and negative
              indices start from -1
- 23/08/20: added Node.id attribute which is set/updated with
            NodeType.update_id() - it is set as follows:
            - node data used as base
            - only digits and characters kept from node's data
            - all characters made lowercase
            - all words separated by underscores
            - the minimum length is 6 characters (unless data is less than
              6 characters long)
            - once 6 character length is reached, the current word will be
              the last part of the ID and the rest are omitted
            - if it starts with a digit, an underscore prefix is added
            - if another node (sibling) has the same ID, an underscore suffix
              is added to the end (as many as needed to get a unique ID)
            - .update_id() should be called whenever a node's data is changed
              or created or moved (api.edit_data calls it) and it is called
              in Node/Root.__init__
- 23/08/20: added 'what id' extension to 'what' command to show current node ID
- 24/08/20: the syntax for node references is as follows:
            - references start with either a dot, double dot, tilde, slash,
              keyword or number:
              - dot (.): reference starts with the current node
              - double dot (..): reference starts with the parent node
              - tilde (~): reference starts with the root node
              - slash (/): reference starts witht the current node (implied
                           starting dot)
              - keyword: reference starts with node with matching ID in
                         current node's list of children
              - number: reference starts with the node with the given index
                        in the current node's list of children (starting at 1)
            - references can refer to child nodes of the first node, each one
              separated by a slash
            - the following references can contain a double dot, keyword or
              number which behave as listed above but the 'current node' is
              treated as the previous node in the reference
- 24/08/20: added STAR (*) token to CLI input which can be used to handle
            parsing problems - it will be parsed silently
            - for example, if there is a command 'edit tag value' and a command
              'edit tag' whose signature begins with a keyword(-like) element
              with the value 'value', the command 'edit tag value' will be
              chosen if 'edit tag value' is typed into the CLI
            - however, if 'edit tag * value' is typed, 'edit tag' command will
              be chosen
            - a star can occur after the command name or between signature
              elements
            - for example, if a signature contains
              'STRING=input1* STRING=input2' and 2 strings are entered into the
              CLI, both will be consumed by the first input since it is a
              variable element (and parsed greedily)
            - however, typing 'string' * 'string' will cause the parser to stop
              parsing the 2nd string as the first input
- 24/08/20: added api.switch_node(node) which will move traversal into the
            given node
- 26/08/20: structure.InputType adds subclasses to structure._inputs
            [dict(token: class)] to indicate the given keyword (uppercase)
            should be treated as an input and not a keyword by the
            signature lexer
- 26/08/20: lexers.SignatureLexer will now produce an INPUT token instead
            of the previous STRING, NUMBER and NODEREF tokens so custom
            input types can be added
            - the token value will be the name of the input e.g. 'STRING'
            - all uppercase names that appear in signatures will be converted
              to lowercase as before unless they are in structure._inputs
- 26/08/20: all input elements in command signatures must be a subclass of
            structure.InputType
            - they should have a .type attribute which is the value of the
              INPUT token produced by the signature lexer that matches the
              class
- 26/08/20: added 'input options' to command signatures:
            - input tokens can have a slash followed by a single keyword
              indicating an option - e.g. 'NODEREF/child=node'
            - options should be a .options [list/tuple] attribute in the
              structure.InputType subclass that implements the parsing
            - the .option attribute will be set to the option (or None) if
              the option is specified in a command signature
            - input options only affect parsing of numbers so input_handlers
              should still perform checks if the command is called manually
- 26/08/20: api.tree.traversal_numbers removed as it is now obsolete, with
            Node.id having repalced it
            - api.return_from_node no longer returns the index of the child
            - changed default plugin.display_hook to use node IDs instead of
              node references as the first line
- 26/08/20: added input options 'positive' and 'negative' for NumberInput
            - positive: numbers 0 or more (0 is included)
            - negative: less than 0
- 26/08/20: added input options 'forward' and 'child' for NodeRefInput
            - forward: references have to be within child nodes
              - double dot .. is not allowed here and it cannot begin with the
                tilde (~) character
            - child: references have to be a single child node and cannot go
                     any deeper
              - only a single number or keyword (node ID) is allowed
              - it may start with ./
- 26/08/20: changed HelpCommand.signature_syntax so that each signature element
            has its own implementation of .signature_syntax in its class body
            - added '<node>' for NodeRefInput.signature_syntax
- 27/08/20: added api.tests.is_child_reference and .is_forward_reference
            which can check if references [node] comply to 'child' and
            'forward' options
- 27/08/20: added api.tests.is_keyword which checks if the keyword contains
            only digits, characters or underscores (no leading digits)
- 27/08/20: added api.child_index_from_node(node) which will return what index
            in the parent's child list the node is
            - raises NodeError if the node is the root node



**clean up files before committing**

IN PROGRESS:
search command 24/08/20

NEXT UP:
- add search option
- add backward references or absolute references from root

TODOS:

[API and plugins]

- consider adding a 'master' command execution hook so that a plugin can
  intercept command calls and delegate calls to their custom hooks instead
  of hard-coded hook names (for default commands)
  - commands will need to have IDs
  - this could allow plugins to interact

- make some input sanitation functions for tags (e.g. to remove whitespace)

add back input_handler function and pre-written functions like
get_yes_or_no from the unseen pre-pre-release version

- add environment variables $depth $data (perhaps?)
- add ALL the plugin hooks for EACH API base function SEPRATELY


[Commands-related things]
- add float/drop/copy commands

- make the 'in' command safe for use with any command that may call
  api.Tree.return_from_node
- add search finally
- consider having an undo option

- make a general command queue object to hold both command queue lists as one
  and know where new commands should be added
- dot parsing in command signatures (e.g. 2.1.3) and check if node.node.node is
  a valid or child that exists

- in api.manual_execute, add options to queue the command in command_queue or
  post_commands (with index)


[Input-related things]
- loading multiple trees
